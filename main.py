#lst = [5, 10, -9, 12]

# for el in lst:
#     print(el, end='')

# print()

# for i in range(len(lst)):
#     print(i, end=' ')

# for i in range(len(lst)):
#     print(f"{i} : {list[i]}")

###################
#Срез списка
# lst = [5, 10, -9, 12]
# #      0   1   2   3
# print(lst[2:len(lst)])
# print(lst[:3])
# print(lst[3:])

#37min работа со списками, как меняем и добавляем
#39 функция deepcopy

####################
#Добавляем элементы из одного списка в другой

# lst = [1, 2, 3, 12, 33 , 33, 234, 34, 56, 67 ]
# st = set()
# for el in lst:
#     st.add(el)

# print(st)

# # Есть ли в списке дупликат
# if len(lst) == len(set(lst)):
#     print("No")
# else: print("YES")

################################
#Словари
#50min

# dt = {i: 0 for i in range(5)}
# print(dt)

################################

#Дан список чисел. Определите, сколько в нем встречается различных чисел.
#Input: [1, 1, 2, 0, -1, 3, 4, 4]
#Output: 6

#lst = [1, 1, 2, 0, -1, 3, 4, 4]
#print(len(set(lst)))

#второй вариант решения
# lst = [3, 5, 4, 34, 6, 23, 3, 50, 23, 12, 6, 32]
# boom=[]
# for i in lst:
#     if (lst.count(i) == 1):
#         boom.append(i)
#         print(len(boom))

#третий вариант
# lst = [1, 1 ,2 ,0,-1, 3, 4]

# lst_2 = []
# for i in lst:
#     if i not in lst_2:
#         lst_2.append(i)
# print(len(lst_2))
##############################################
#Дана последовательность из N целых чисел и число K.
#Необходимо сдвинуть всю последовательность
#(сдвиг - циклический) на K элементов вправо, K – положительное число.
#Input: [1, 2, 3, 4, 5] k = 3
#Output: [4, 5, 1, 2, 3]
#Примечание: Пользователь может вводить значения списка или список задан изначально.

# lst = [1, 2, 3, 4, 5]
# k = 8
# k = k % len(lst) #действие необходимо нам, если число "к" больше длины списка.
# #Если его не делать, то при больших числах задача перстает работать
# lst = lst[k:]+lst[:k]
# print(lst)

#второй вариант
#lst = [1, 2, 3, 4, 5]
#k = 3
#lst_1 = []
#for i in range(k):
#    lst.append(lst[0])
#    lst.pop(0)
#print(lst)

#Третий вариант
# arr = [1, 2, 3, 4, 5]
# k = 3

# for i in range(k - 1):
#     arr.insert(0, arr[len(arr) - 1])
#     arr.pop()
# print(arr)

#####################################
#Напишите программу для печати всех уникальных значений в словаре.
#Input: [{"V": "S001"}, {"V": "S002"}, {"VI": "S001"},
#{"VI": "S005"}, {"VII": " S005 "}, {" V ":" S009 "}, {" VIII":" S007 "}]
#Output: {'S005', 'S002', 'S007', 'S001', 'S009'}
#Примечание: Список словарей задан изначально. Пользователь его не вводит.

#dt = {"V": "S001", "V1": "S002", "V2": "S001", "V3": "S005", "VII": " S005 ", "V5":" S009 ", "VIII":" S007 "}

#print(dt.keys())
#print(dt.values())
#print(dt.items())
#Варианты решения задачи. Оперируя комбинациями, можно вывести требуемый результат.
#for d in dt:
#   print(d)
#for key in dt:
#    print(key)
#или
#for key in dt.keys():
#    print(key)
#по ключу и значению
#for el in dt.items():
#    print(el)
#или
#for key, value in dt.items():
#   print(key, value)
#или
#for key in dt:
#    value = dt[key]
#    print(key, value)
#Решение задачи

# lst = [{"V": "S001"}, {"V": "S002"}, {"VI": "S001"},
#        {"VI": "S005"}, {"VII": " S005 "}, {" V ":" S009 "}, {" VIII":" S007 "}]
# st = set()
# for dt in lst:
#     for value in dt.values():
#         st.add(value.strip())
# print(*st)

# #Второй вариант
# my_lst = set([list(dt.values())[0] for dt in lst]) #set - берет множество, чтобы не было повторений
# print(my_lst)
# #1-55min

#Дан массив, состоящий из целых чисел. Напишите программу, которая подсчитает количество
#элементов массива, больших предыдущего (элемента с предыдущим номером)
#Input: [0, -1, 5, 2, 3]
#Output: 2 (-1 < 5, 2 < 3)
#Примечание: Пользователь может вводить значения списка или список задан изначально.

# lst = [0, -1, 5, 2, 3]
# ctn = 0
# for i in range(1, len(lst)): #начинаем с первого элемента, так как будем сравнивать с первым значением у которого индекс 0
#     if lst[i] > lst[i-1]:
#         ctn +=1
# print(ctn)
#################################
#Домашнее задание с проверкой через сайт

#Требуется вычислить, сколько раз встречается некоторое число k в массиве list_1.
#Найдите количество и выведите его.
#list_1 = [1, 2, 3, 3, 4, 3, 4, 4, 5, 3, 5]
#k = int(input())
#Первый вариант
#for el in list_1:
#    sum = list_1.count(k)
#print(sum)
#Второй вариант
#print(list_1.count(k))

##############################
#Требуется найти в массиве list_1 самый близкий по величине элемент к заданному числу k и вывести его.
#list_1 = [1, 2, 3, 4, 5]
#k = 6
#output = 5

# import math
# list_1 = [1, 2, 3, 4, 5]
# k = 6
# dif = 0
# i = 0
# lst = []
# while i < len(list_1):
#         dif = abs(k - list_1[i])
#         lst.append(dif)
#         i += 1
# #       print(a, end=' ') проверял вид элементов после выполения "вычитания по модулю"
# #print(lst) проверял, как был создан новый список разницы
# min(lst)   #проверка print(min(lst))
# lst.index(min(lst)) #p проверка rint(lst.index(min(lst)))
# print(list_1[lst.index(min(lst))])

########################################

## В настольной игре Скрабл (Scrabble) каждая буква имеет определенную ценность.
## В случае с английским алфавитом очки распределяются так:
## A, E, I, O, U, L, N, S, T, R – 1 очко;
## D, G – 2 очка;
## B, C, M, P – 3 очка;
## F, H, V, W, Y – 4 очка;
## K – 5 очков;
## J, X – 8 очков;
## Q, Z – 10 очков.
## А русские буквы оцениваются так:
## А, В, Е, И, Н, О, Р, С, Т – 1 очко;
## Д, К, Л, М, П, У – 2 очка;
## Б, Г, Ё, Ь, Я – 3 очка;
## Й, Ы – 4 очка;
## Ж, З, Х, Ц, Ч – 5 очков;
## Ш, Э, Ю – 8 очков;
## Ф, Щ, Ъ – 10 очков.
## Напишите программу, которая вычисляет стоимость введенного пользователем слова k и
## выводит его. Будем считать, что на вход подается только одно слово, которое
## содержит либо только английские, либо только русские буквы.
# lst = [{"V": "S001"}, {"V": "S002"}, {"VI": "S001"},
#        {"VI": "S005"}, {"VII": " S005 "}, {" V ":" S009 "}, {" VIII":" S007 "}]
# st = set()
# for dt in lst:
#     for value in dt.values():
#         st.add(value.strip())
# print(*st)

# lst = [
#     {"A, E, I, O, U, L, N, S, T, R" : "1"},
#     {"D, G" : "2"},
#     {"B, C, M, P" : "3"},
#     {"F, H, V, W, Y" : "4"},
#     {"K" : "5"},
#     {"J, X" : "8"},
#     {"Q, Z" : "10"},
#     {"А, В, Е, И, Н, О, Р, С, Т" : "1"},
#     {"Д, К, Л, М, П, У" : "2"},
#     {"Б, Г, Ё, Ь, Я" : "3"},
#     {"Й, Ы" : "4"},
#     {"Ж, З, Х, Ц, Ч" : "5"},
#     {"Ш, Э, Ю" : "8"},
#     {"Ф, Щ, Ъ" : "10"}
# ]
# #k = 'мама' #Подставлял значения как на сайте
# #k = k.upper() #Чтобы перевести в верхний регистр
# world = input("Введите слово: ").upper()
# sum1 = 0
# for letter in world:
#        for dt in lst:
#               for key, value in dt.items():
#                      if letter in key:
#                             resut = value
#                             resut = int(resut)
#                             sum1 = sum1 + resut
# print(sum1)


#################
#random генерация 0 и 1
# from random import randint

# n = 10
# lst = [randint(0, 1) for i in range(n)]
# print(lst)
#####################
# #если его запускать, то random будет выводить 0 или 1 за один цикл выполнения
# from random import randint, choice

# lst = [0, 1]
# ch = choice(lst)
# print(ch)
######################
# #это цикл не один выбор, а выборы, так как стоит choices b здесь мы генерим не 0 и 1,
# #а вариан Орел или решка
# from random import randint, choices

# n=10 #указываем количество бросков
# lst = ['O', 'P']
# ch = choices(lst, k=n)
# print(ch)

# Второй вариант

# from random import randint, choices
# n=10 #указываем количество бросков
# coins = choices(['O', 'P'], k=n)
# print(coins)
# print(coins.count('O'))
# print(coins.count('P'))

#Третий вариант
#находим минимальное количество, которое надо перевернуть, чтобы все были одинаковые
# from random import randint, choices
# n=10
# coins = choices(['O', 'P'], k=n)
# print(coins)
# print(min(coins.count('O'), coins.count('P')))

#Четвертый вариант
#выводим все в одну строчку
#from random import randint, choices
#можно использовать вариант 1 или 2
#вариант4.1
## := означает, = мы приравняли к coins выражение справа, : вернули в работу
#n=10
#print(coins := choices(['O', 'P'], k=n), '\n', min(coins.count('O'), coins.count('P')))
#вариант4.2
# В Print используем так называемы маржовый оператор
# print(coins, ) здесь мы вставили то что вычилили в верхнем выражении и вернули в работу
# n=10
# coins = choices(['O', 'P'], k=n)
# print(coins, '\n', min(coins.count('O'), coins.count('P')))
#вариант4.3
#print(coins := choices(['O', 'P'], k=int(input("Количество монет: "))), '\n', min(coins.count('O'), coins.count('P')))
#########################

# ans = [[i,j] for i in range(3) for j in range(3)]
# print(ans)

# # эквиваент из цикла
# for i in range(3):
#     for j in range(3):
#         print([i, j])

# #создаем список из списков (добавили скобки [])
# ans = [[[i,j] for i in range(3)] for j in range(3)]
# print(ans)

#############################################
#Пример домашней работы про Петю и Катю, где загадали числа и известна сумма и произведение
#представлено решение без формулы дискриминанта
# s, p = 12, 35
# # создать пару x и y (x, Y), далее x создаем из условия for x in range(1001), y создаем аналогично
# # далее проверяем набор условий. Задача решена методом перебора.
# ans = [(x, y) for x in range(1001) for y in range(1001) if x + y == s and x * y == p and x <= y]
# print(*ans) #* в print указывает что мы распаковываем ответ. можно ее убурать и видно как меняется формат

##################################
#Пример домашений задачи со степенью 2к
#n = int(input('N: '))
#print(*[2 ** i for i in range(n) if 2 ** i <= n])
#второй вариант
# from math import log2, ceil
# n = int(input('N: '))
# print(*[2 ** i for i in range(ceil(log2(n) + 1)) if 2 ** i <= n])
##################################
#Вводим строчку и разделеяем ее через splitю Получаем строковый тип. Затем через for мы
#меняем тип переменной, чтобы она была int
# numbers = input().split()
# print(numbers)

# for i in range(len(numbers)):
#     numbers[i] = int(numbers[i])

# print(numbers)

# #альтернативное решение №1 через map
# numbers = input().split()
# numbers = list(map(int, numbers))
# print(numbers)

#альтернативное решение №2
# numbers = list(map(int, input().split()))
# print(numbers)

########################################
# #Напишите программу, которая принимает на вход строку, и отслеживает, сколько раз каждый
# # символ уже встречался. Количество повторов добавляется к символам с помощью постфикса
# # формата _n.
# #Input: a a a b c a a d c d d
# #Output: a a_1 a_2 b c a_3 a_4 d c_1 d_1 d_2
# #Для решения данной задачи используйте функцию .split()

# lst = 'a a a b c a a d c d d'.split()
# dct ={}
# for i in lst:
#      if i not in dct:
#        print(i, end = ' ')
#      else:
#        print(f"{i}_{dct[i]}", end=' ')
#      dct[i] = dct.get(i, 0) + 1 #можно поставить эту строчку в разные части цикла и посмотреть результат

##################################

# # Пользователь вводит текст(строка). Словом считается последовательность непробельных
# # символов идущих подряд, слова разделены одним или большим числом пробелов.
# # Определите, сколько различных слов содержится в этом тексте.
# # Input: She sells sea shells on the sea shore The shells
# # that she sells are sea shells I'm sure.So if she sells sea
# # shells on the sea shore I'm sure that the shells are sea
# # shore shells
# # Output: 13

# lst = "She sells sea shells on the sea shore The shells \
# that she sells are sea shells I'm sure.So if she sells sea \
# shells on the sea shore I'm sure that the shells are sea \
# shore shells"

# lst = lst.lower().replace('.',' ').split()
# print(len(set(lst)))

###################################

#Ваня и Петя поспорили, кто быстрее решит следующую задачу: “Задана последовательность
#неотрицательных целых чисел. Требуется определить значение наибольшего элемента
#последовательности, которая завершается первым встретившимся нулем (число 0 не входит в
#последовательность)”. Однако 2 друга оказались не такими смышлеными. Никто из ребят не смог
#до конца сделать это задание. Они решили так: у кого будет меньше ошибок в коде, тот и
#выиграл спор. За помощью товарищи обратились к Вам, студентам.


#n = 1
#mx = -1
# while n != 0:
#     n = int(input())
#     if n > mx:
#         mx = n
# print(mx)

###########################################
# Даны два неупорядоченных набора целых чисел (может быть, с повторениями).
# Выдать без повторений в порядке возрастания все те числа, которые встречаются в обоих
# наборах. Пользователь вводит 2 числа. n — кол-во элементов первого множества.
# m — кол-во элементов второго множества. Затем пользователь вводит сами элементы множеств.


ent = str(input("R - random, M - manual2, C - copy/past. Enter R or N or C: ")).upper()
R = str('R')
M = str('M')
C = str('C')
if ent == R:
       n1 = int(input("Количество значение в первом списке: "))
       n2 = int(input("Количество значение во втором списке: "))
       from random import randint
       lst1 = [randint(0, 100) for i in range(n1)]
       lst2 = [randint(0, 100) for i in range(n2)]
       print("Сгенерированный список №1: ", lst1)
       print("Сгенерированный список №2: ", lst2)
elif ent == M:
       n1 = int(input("Количество значение в первом списке: "))
       n2 = int(input("Количество значение во втором списке: "))
       print("Ввод значение первого списка, через Enter")
       print("Первый список", lst1 := [ int(input()) for i in range(n1) ])
       print("Ввод значение второго списка, через Enter")
       print("Второй список", lst2 := [ int(input()) for i in range(n2) ])
elif ent == C:
       print("Необходимо вставить набор чисел для первого списка разделенных пробелами и нажать Enter")
       lst1=list(map(int, input().split()))
       print("Первый список: ",lst1)
       print("Необходимо вставить набор чисел для второго списка разделенных пробелами и нажать Enter")
       lst2=list(map(int, input().split()))
       print("Второй список:",lst2)
else:
       print("Вы выбрали несуществующий способ")
       lst1 = []
       lst2 = []
       
if not lst1 and not lst2:
       print("Списки пустые")
else:
       res = list(set(lst1) & set(lst2))
       res.sort()
       print("Результат сравнения и сортировки по возрастанию", '\n', res)


#########################################################
# В фермерском хозяйстве в Карелии выращивают чернику. Она растёт на круглой грядке, причём
# кусты высажены только по окружности. Таким образом, у каждого куста есть ровно два соседних.
# Всего на грядке растёт N кустов. Эти кусты обладают разной урожайностью, поэтому ко времени
# сбора на них выросло различное число ягод — на i-ом кусте выросло ai ягод.
# В этом фермерском хозяйстве внедрена система автоматического сбора черники.
# Эта система состоит из управляющего модуля и нескольких собирающих модулей.
# Собирающий модуль за один заход, находясь непосредственно перед некоторым кустом,
# собирает ягоды с этого куста и с двух соседних с ним. Напишите программу для нахождения
# максимального числа ягод, которое может собрать за один заход собирающий модуль,
# находясь перед некоторым кустом заданной во входном файле грядки.

# bush = int(input("Количество кустов: "))
# from random import randint
# berry = [randint(0, 100) for i in range(bush)]
# print("Количество ягод на каждом кусте: ")
# print(berry)
# count = []
# i = 0
# while i <= len(berry):
#     if i < len(berry[:-2]):
#        a = sum(berry[i:i+3])
#     elif i == len(berry[:-2]):
#        berry = berry[1:]+berry[:1]
#        a = sum(berry[-3::])
#     elif i == len(berry[:-1]):
#        berry = berry[1:]+berry[:1]
#        a = sum(berry[-3::])
#     i += 1
#     count.append(a)
# print("Список суммы ягод трех соседних кустов: ", '\n', count)
# print("Максимальное число ягод: ", '\n', max(count))